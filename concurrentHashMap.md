# ConcurrentHashMap

## 线程不安全的HashMap

多线程环境下，使用HashMap进行put操作会引起死循环。

原因：



## 效率低下的HashTable

使用synchronized保证线程安全。线程竞争激烈的情况下，其他线程会被阻塞。

***锁分段技术***

竞争激烈的并发环境下效率低下的原因是所有访问HashTable的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。

***hash处理冲突的方法***

* 开放地址法：线性探测再散列，二次探测再散列，随机探测再散列。
* 再哈希法；
* 链地址法
* 建立一个公共溢出区

## ConcurrentHashMap源码解读之size

### LongAdder

jdk8中新引入了类LongAdder，分而治之的求和方式。

