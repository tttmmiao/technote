[TOC]
# 分布式

## concepts
* CAP理论
	- C: consistency 一致性
	  
	  > all nodes see the same data at the same time.
	- A: available 可用性
	
	 > reads and writes always succeed. 
	
	- P: partition tolerance 局部容错性
	 > the system continues to operate despite arbitrary message loss or failure of part of the system.
* BASE理论
	> BASE = Basically Available + Soft state + Eventrually consistent
	
## 最终一致性
* 单一的系统，功过spring的事务保证数据的强一致性。
* 分布式系统最终一致性的实现方式：
	需要根据具体的业务场景
	- 基于消息队列的最终一致性
	- 基于消息队列+定时任务补偿机制
	- 业务系统的幂等性控制
      - mvcc方案
      
      	```sql
  udpate tablexxx set price = price - #{elta} where price - #{delta} >=0 
      	```
     	
      	```sql
  	update tablexxx set name = #{name}, version = version + 1 where version = #{version} 
   
      	```
      
      	
      
      	
      - 如去重表（通过数据库唯一键保证）
      -  分布式锁
      -  api层面的幂等：request中增加一个唯一标志如uuid, 服务端根据uuid来去重


## 分布式锁的实现
* 基于数据库实现分布式锁
	
  创建一张锁表，要锁住某个方法或者资源时，增加一条记录，要释放锁的时候删除记录即可。（表中需要有唯一键约束）
  
  *存在问题*：
  - 数据库是单点 
  - 锁没有失效时间
  - 是非阻塞的。insert失败，直接报错。没有获得锁的线程不会进入排队队列，想再次获得锁需要再次出发insert操作。
  - 是非重入的。同一个线程在没有释放锁之前无法再次获得该锁，因为表中数据已经存在了。
  *解决方式*
  * 单点问题：采用主从方式
  * 失效时间：job定时清理
  * 非阻塞：while循环，直到插入成功
  * 非重入：表中记录锁机器和线程信息，下次取锁时先查数据库。

 **基于数据库的排他锁**
 mysql的innodb引擎
 select **** for update
 
 > innodb 引擎在加锁的时候，只有通过索引检索的时候才使用行级锁，否则会使用表级锁。另外，mysql内部优化不一定会选择指定索引，导致全表扫描
 
* 基于缓存（redis）
  redis的setnx方法
  
* 基于zookeeper实现分布式锁

## zookeeper

## session分布式方案

## 消息系统
* 堆积问题

* 重发问题

* 顺序问题
